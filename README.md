# 0xNEKO

<div align="center">

![Version](https://img.shields.io/badge/version-1.0.0-blue)
![Solidity](https://img.shields.io/badge/solidity-0.8.20-purple)
![License](https://img.shields.io/badge/license-MIT-green)

**A CPU-optimized Proof-of-Work minable ERC20 token**

[Features](#features) â€¢ [Quick Start](#quick-start) â€¢ [API Reference](#api-reference) â€¢ [Mining Guide](#mining-guide) â€¢ [Security](#security)

---

**ğŸŒ Languages:** [English](README.md) | [ç®€ä½“ä¸­æ–‡](docs/README.sc.md) | [ç¹é«”ä¸­æ–‡](docs/README.tc.md) | [æ—¥æœ¬èª](docs/README.ja.md) | [EspaÃ±ol](docs/README.es.md) | [Deutsch](docs/README.de.md) | [Ğ ÑƒÑÑĞºĞ¸Ğ¹](docs/README.ru.md)

</div>

---

## Overview

0xNEKO is a decentralized, minable ERC20 token that uses a novel **NekoCycle** Proof-of-Work algorithm. The mining process involves finding cycles in a graph structure, with edge generation using **BranchingHash** - a data-dependent branching algorithm designed to optimize for CPU mining.

### Key Highlights

- ğŸ”’ **Fully Decentralized** - No admin keys, no owner privileges
- â›ï¸ **CPU-Optimized** - BranchingHash uses data-dependent branching
- ğŸ”— **Chain-Bound** - Solutions tied to specific chain ID and miner address
- ğŸ“ˆ **ASERT Difficulty** - Smooth exponential difficulty adjustment
- ğŸ’° **Smooth Emission** - Gradual decay reward curve with tail emission

---

## Features

### NekoCycle Proof-of-Work

The mining algorithm requires finding a **42-length cycle** in a bipartite graph where edges are generated by the `_branchingHash()` function.

```
Edge 0: (uâ‚€, vâ‚€)
Edge 1: (uâ‚, vâ‚) where uâ‚ = vâ‚€
Edge 2: (uâ‚‚, vâ‚‚) where uâ‚‚ = vâ‚
...
Edge 41: (uâ‚„â‚, vâ‚„â‚) where uâ‚„â‚ = vâ‚„â‚€ AND vâ‚„â‚ = uâ‚€
```

### BranchingHash Algorithm

Edge generation uses data-dependent branching to create execution path divergence:

```solidity
function _branchingHash(bytes32 root, uint256 edgeIndex) internal pure returns (uint256 u, uint256 v) {
    uint256 state = uint256(keccak256(abi.encode(root, edgeIndex)));
    
    unchecked {
        for (uint256 i = 0; i < 8; ++i) {
            uint256 mode = state & 0x7;  // 8 possible branches
            
            if (mode == 0) state = uint256(keccak256(abi.encode(state)));
            else if (mode == 1) state = state ^ (state << 13);
            else if (mode == 2) state = state + 0x123456789;
            else if (mode == 3) state = (state >> 5) | (state << 251);
            else if (mode == 4) state = state * 0x1A2B3C;
            else if (mode == 5) state = ~state;
            else state = state ^ 0xFF00FF00FF00FF00;
            
            state ^= i;
        }
    }

    u = uint256(keccak256(abi.encode(state, uint8(0)))) & 0xFFFFFFFFFFFFFFFF;
    v = uint256(keccak256(abi.encode(state, uint8(1)))) & 0xFFFFFFFFFFFFFFFF;
}
```

### ASERT Difficulty Adjustment

The contract uses **Absolutely Scheduled Exponentially weighted Rising Target (ASERT)** algorithm:

```
newTarget = anchorTarget Ã— 2^((actualTime - expectedTime) / (halfLife Ã— targetBlockTime))
```

| Parameter | Value | Description |
| :--- | :--- | :--- |
| Half-life | 2,880 blocks | ~2 days at target rate |
| Target Block Time | 60 seconds | 1 minute between blocks |
| Anchor Update | Every 100 blocks | Prevents calculation drift |
| Min Target | 2Â²â°â° | Maximum difficulty |
| Max Target | 2Â²âµâ´ | Minimum difficulty |

### Smooth Emission Curve

Instead of halving events, 0xNEKO uses a smooth decay formula:

```
reward = (maxSupply - tokensMinted) >> emissionSpeedFactor
```

With tail emission floor:
```
if (reward < 0.1 NEKO) reward = 0.1 NEKO
```

---

## Token Economics

| Parameter | Value |
| :--- | :--- |
| **Token Name** | 0xNEKO |
| **Token Symbol** | 0xNEKO |
| **Decimals** | 18 |
| **Maximum Supply** | 1,000,000,000 (1 Billion) |
| **Initial Reward** | ~953.67 NEKO |
| **Emission Speed Factor** | 20 |
| **Tail Emission** | 0.1 NEKO minimum |
| **Target Block Time** | 60 seconds |

### Emission Schedule

| Tokens Minted | Block Reward |
| ---: | ---: |
| 0 | 953.67 NEKO |
| 100M (10%) | 858.31 NEKO |
| 500M (50%) | 476.84 NEKO |
| 900M (90%) | 95.37 NEKO |
| 990M (99%) | 9.54 NEKO |
| 999M (99.9%) | 0.95 NEKO |
| 999.9M+ | 0.1 NEKO (tail) |

---

## Quick Start

### Prerequisites

- Node.js v18+
- npm or yarn

### Installation

```bash
# Clone the repository
git clone https://github.com/your-repo/0xneko.git
cd 0xneko

# Install dependencies
npm install
```

### Compile

```bash
npx hardhat compile
```

### Test

```bash
npx hardhat test
```

### Deploy

```bash
# Local development
npx hardhat run scripts/deploy.js --network hardhat

# Testnet (configure in hardhat.config.js first)
npx hardhat run scripts/deploy.js --network sepolia
```

---

## API Reference

### Mining Functions

#### `mint(uint256 nonce, uint256[] calldata solution)`

Submit a valid mining solution to mint tokens.

**Parameters:**
| Name | Type | Description |
| :--- | :--- | :--- |
| `nonce` | uint256 | Random value to modify the challenge |
| `solution` | uint256[] | Array of 42 edge indices forming a cycle |

**Requirements:**
- `solution.length == 42`
- `hash(challengeNumber, solution, msg.sender, nonce, chainid) < miningTarget`
- All edges must form a valid closed cycle

**Events:**
```solidity
event Mint(address indexed miner, uint256 reward, uint256 indexed epochCount, bytes32 newChallenge, uint256 newTarget);
event DifficultyAdjusted(uint256 oldTarget, uint256 newTarget, uint256 epochCount);
```

---

### Query Functions (View)

#### `getBlockInfo()`

Returns all mining-related information in a single call. **Recommended for miners.**

```solidity
function getBlockInfo() external view returns (
    bytes32 challenge,    // Current challenge hash
    uint256 target,       // Current difficulty target
    uint256 reward,       // Current block reward
    uint256 epoch,        // Total blocks mined
    uint256 supply,       // Total tokens minted
    uint256 remaining     // Tokens remaining to be minted
);
```

**Example (ethers.js):**
```javascript
const info = await contract.getBlockInfo();
console.log("Challenge:", info.challenge);
console.log("Target:", info.target.toString());
console.log("Reward:", ethers.formatEther(info.reward), "NEKO");
```

---

#### `getChallengeNumber()`

Returns the current challenge hash that miners must solve against.

```solidity
function getChallengeNumber() external view returns (bytes32);
```

---

#### `getMiningTarget()`

Returns the current difficulty target. Lower value = harder to mine.

```solidity
function getMiningTarget() external view returns (uint256);
```

---

#### `getMiningReward()`

Returns the current block reward in wei.

```solidity
function getMiningReward() external view returns (uint256);
```

---

#### `getDifficulty()`

Returns human-readable difficulty (higher = harder).

```solidity
function getDifficulty() external view returns (uint256);
// Returns: type(uint256).max / miningTarget
```

---

#### `getLocalChallenge(address miner, uint256 nonce)`

Get the local challenge hash for off-chain cycle computation.

```solidity
function getLocalChallenge(address miner, uint256 nonce) external view returns (bytes32);
```

**Example:**
```javascript
const localChallenge = await contract.getLocalChallenge(minerAddress, nonce);
// Use this for off-chain cycle finding
```

---

#### `computeEdge(bytes32 root, uint256 edgeIndex)`

Compute an edge (u, v) for the given challenge and edge index.

```solidity
function computeEdge(bytes32 root, uint256 edgeIndex) external pure returns (uint256 u, uint256 v);
```

**Example:**
```javascript
const [u, v] = await contract.computeEdge(localChallenge, edgeIndex);
console.log(`Edge ${edgeIndex}: (${u}, ${v})`);
```

---

#### `verifySolution(uint256 nonce, uint256[] calldata solution)`

Pre-verify a solution before submitting (saves gas on invalid submissions).

```solidity
function verifySolution(uint256 nonce, uint256[] calldata solution) external view returns (
    bool valid,           // Whether solution meets difficulty
    bytes32 solutionHash  // The computed solution hash
);
```

---

#### `getDifficultyInfo()`

Get ASERT difficulty adjustment parameters.

```solidity
function getDifficultyInfo() external view returns (
    uint256 currentTarget,    // Current mining target
    uint256 anchor,           // Anchor target for ASERT
    uint256 anchorEpochNum,   // Epoch when anchor was set
    uint256 anchorTimestamp,  // Timestamp when anchor was set
    uint256 halfLife          // Half-life in blocks
);
```

---

#### `getEconomicsInfo()`

Get token economics information.

```solidity
function getEconomicsInfo() external view returns (
    uint256 maxSupply,        // Maximum supply (1B)
    uint256 minted,           // Tokens minted so far
    uint256 currentReward,    // Current block reward
    uint256 minReward,        // Tail emission (0.1 NEKO)
    uint256 emissionFactor    // Speed factor (20)
);
```

---

#### `getNetworkStats()`

Get estimated network statistics.

```solidity
function getNetworkStats() external view returns (
    uint256 estimatedHashrate,   // Estimated network hashrate
    uint256 timeSinceAnchor,     // Seconds since anchor
    uint256 blocksSinceAnchor    // Blocks since anchor
);
```

---

#### `getChainInfo()`

Get chain binding information.

```solidity
function getChainInfo() external view returns (
    uint256 deployChainId,    // Chain ID at deployment
    uint256 currentChainId,   // Current chain ID
    uint256 deployTime        // Deployment timestamp
);
```

---

#### `getConstants()`

Get all protocol constants.

```solidity
function getConstants() external pure returns (
    uint256 cycleLength,          // 42
    uint256 maxSupply,            // 1,000,000,000 Ã— 10Â¹â¸
    uint256 targetBlockTime,      // 60
    uint256 emissionSpeedFactor,  // 20
    uint256 minReward,            // 10Â¹â· (0.1 NEKO)
    uint256 asertHalfLife,        // 2880
    uint256 maxTarget,            // 2Â²âµâ´
    uint256 minTarget             // 2Â²â°â°
);
```

---

### ERC20 Standard Functions

| Function | Description |
| :--- | :--- |
| `name()` | Returns "0xNEKO" |
| `symbol()` | Returns "0xNEKO" |
| `decimals()` | Returns 18 |
| `totalSupply()` | Returns total minted tokens |
| `balanceOf(address)` | Returns account balance |
| `transfer(to, amount)` | Transfer tokens |
| `transferFrom(from, to, amount)` | Transfer with allowance |
| `approve(spender, amount)` | Set allowance |
| `allowance(owner, spender)` | Check allowance |

---

## Mining Guide

### Overview

```
1. Get current challenge: getChallengeNumber()
2. Generate local challenge: hash(challenge, miner, nonce, chainid)
3. Build graph edges using computeEdge() or local implementation
4. Find 42-cycle in graph
5. Verify solution hash < target
6. Submit: mint(nonce, solution)
```

### Step-by-Step

#### 1. Fetch Mining Info

```javascript
const { challenge, target, reward } = await contract.getBlockInfo();
```

#### 2. Generate Local Challenge

```javascript
const nonce = Math.floor(Math.random() * 2**32);
const localChallenge = await contract.getLocalChallenge(minerAddress, nonce);
```

#### 3. Build Graph & Find Cycle

```javascript
// Build edge map
const edges = {};
for (let i = 0; i < SEARCH_SPACE; i++) {
    const [u, v] = await contract.computeEdge(localChallenge, i);
    // Store edge i: u -> v
    if (!edges[u]) edges[u] = [];
    edges[u].push({ v, index: i });
}

// Find 42-cycle using DFS/cycle detection algorithm
const solution = findCycle(edges, 42);
```

#### 4. Verify Before Submission

```javascript
const { valid, solutionHash } = await contract.verifySolution(nonce, solution);
if (!valid) {
    console.log("Solution invalid, trying again...");
    continue;
}
```

#### 5. Submit Solution

```javascript
const tx = await contract.mint(nonce, solution);
await tx.wait();
console.log("Block mined!");
```

---

## Gas Costs

| Operation | Gas Cost |
| :--- | ---: |
| **Contract Deployment** | ~1,390,000 |
| **Single BranchingHash** | ~24,500 |
| **Verify Cycle (42x)** | ~182,000 |
| **Full Mint Transaction** | ~250,000 |

*Compiled with optimizer enabled, runs=1000*

---

## Security

### Protections

| Protection | Implementation |
| :--- | :--- |
| **Reentrancy** | OpenZeppelin `ReentrancyGuard` |
| **CEI Pattern** | State updates before `_mint()` |
| **Overflow Protection** | ASERT uses `unchecked` with pre-validation |
| **Chain Binding** | Solutions include `block.chainid` |
| **No Admin** | No `Ownable`, fully decentralized |

### Custom Errors

```solidity
error InvalidSolutionLength();  // solution.length != 42
error MaxSupplyReached();       // tokensMinted >= MAX_SUPPLY
error HashAboveTarget();        // hash >= miningTarget
error CycleBroken(uint256 i);   // Edge i doesn't connect
error CycleNotClosed();         // Last edge doesn't close cycle
```

---

## Project Structure

```
0xneko/
â”œâ”€â”€ contracts/
â”‚   â””â”€â”€ 0xNEKO.sol           # Main contract (508 lines)
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ deploy.js            # Deployment script
â”œâ”€â”€ test/
â”‚   â””â”€â”€ 0xNEKO.test.js       # Unit tests
â”œâ”€â”€ abi.json                 # Contract ABI for integration
â”œâ”€â”€ hardhat.config.js        # Hardhat configuration
â”œâ”€â”€ README.md                # This file
â””â”€â”€ package.json
```

---

## Configuration

### hardhat.config.js

```javascript
module.exports = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 1000
      }
    }
  },
  networks: {
    hardhat: { chainId: 31337 },
    // Add your networks here
  }
};
```

---

## License

MIT License - see [LICENSE](LICENSE) for details.

---

## Contributing

Contributions are welcome! Please open an issue or submit a pull request.

---

<div align="center">

**Built with â¤ï¸ for the decentralized future**

</div>
